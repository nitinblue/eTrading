"""
Recommendation & Watchlist Domain Models

Recommendations are first-class objects with their own lifecycle:
    PENDING → ACCEPTED / REJECTED / EXPIRED

They do NOT auto-add to any portfolio. User must consciously accept
with rationale, at which point a WhatIf trade is booked with source tracking.

Watchlists define the universe of symbols screeners run against.
"""

from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import List, Optional, Dict, Any
import uuid


class RecommendationType(Enum):
    """What kind of recommendation this is."""
    ENTRY = "entry"            # Open a new trade
    EXIT = "exit"              # Close an existing trade (take profit / book loss)
    ROLL = "roll"              # Close + re-open at new expiration/strikes
    ADJUST = "adjust"          # Modify an existing trade (add/remove legs)


class RecommendationStatus(Enum):
    """Lifecycle of a recommendation."""
    PENDING = "pending"        # Awaiting user review
    ACCEPTED = "accepted"      # User accepted → trade booked
    REJECTED = "rejected"      # User explicitly rejected
    EXPIRED = "expired"        # Expired without action


@dataclass
class RecommendedLeg:
    """A single leg within a recommendation."""
    streamer_symbol: str = ""      # DXLink symbol (e.g., ".SPY260320P550")
    quantity: int = 0              # positive=buy, negative=sell
    delta_target: Optional[Decimal] = None  # Target delta for strike selection
    strike: Optional[Decimal] = None
    option_type: Optional[str] = None  # "call" or "put"
    expiration: Optional[str] = None   # ISO date string

    def to_dict(self) -> Dict[str, Any]:
        return {
            'streamer_symbol': self.streamer_symbol,
            'quantity': self.quantity,
            'delta_target': float(self.delta_target) if self.delta_target else None,
            'strike': float(self.strike) if self.strike else None,
            'option_type': self.option_type,
            'expiration': self.expiration,
        }


@dataclass
class MarketSnapshot:
    """Market conditions at the time of recommendation."""
    vix: Optional[Decimal] = None
    iv_rank: Optional[Decimal] = None
    iv_percentile: Optional[Decimal] = None
    underlying_price: Optional[Decimal] = None
    rsi: Optional[Decimal] = None
    market_trend: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.utcnow)

    # Technical indicators (populated by TechnicalAnalysisService)
    ema_20: Optional[Decimal] = None
    ema_50: Optional[Decimal] = None
    sma_200: Optional[Decimal] = None
    atr_percent: Optional[float] = None
    directional_regime: Optional[str] = None   # "U" / "F" / "D"
    volatility_regime: Optional[str] = None     # "LOW" / "NORMAL" / "HIGH"
    pct_from_52w_high: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            'vix': float(self.vix) if self.vix else None,
            'iv_rank': float(self.iv_rank) if self.iv_rank else None,
            'iv_percentile': float(self.iv_percentile) if self.iv_percentile else None,
            'underlying_price': float(self.underlying_price) if self.underlying_price else None,
            'rsi': float(self.rsi) if self.rsi else None,
            'market_trend': self.market_trend,
            'ema_20': float(self.ema_20) if self.ema_20 else None,
            'ema_50': float(self.ema_50) if self.ema_50 else None,
            'sma_200': float(self.sma_200) if self.sma_200 else None,
            'atr_percent': self.atr_percent,
            'directional_regime': self.directional_regime,
            'volatility_regime': self.volatility_regime,
            'pct_from_52w_high': self.pct_from_52w_high,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class Recommendation:
    """
    A trade recommendation generated by a screener or external source.

    First-class object with its own lifecycle. Must be explicitly accepted
    by the user before becoming a WhatIf trade.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

    # Recommendation type
    recommendation_type: RecommendationType = RecommendationType.ENTRY

    # Source identification
    source: str = ""                    # TradeSource enum value (e.g. "screener_vix")
    screener_name: str = ""             # Human-readable screener name

    # Trade details
    underlying: str = ""
    strategy_type: str = ""             # StrategyType enum value
    legs: List[RecommendedLeg] = field(default_factory=list)

    # Exit-specific fields (only for EXIT/ROLL/ADJUST types)
    trade_id_to_close: Optional[str] = None     # Trade that triggered this rec
    exit_action: Optional[str] = None           # ActionType value from RulesEngine
    exit_urgency: Optional[str] = None          # "immediate", "today", "this_week"
    triggered_rules: List[str] = field(default_factory=list)  # Rule names that fired
    new_legs: List[RecommendedLeg] = field(default_factory=list)  # For ROLL: the new trade legs

    # Market context at time of recommendation
    market_context: MarketSnapshot = field(default_factory=MarketSnapshot)

    # Scoring
    confidence: int = 5                 # 1-10 scale
    rationale: str = ""                 # Why this trade is recommended
    risk_category: str = "defined"      # "defined" or "undefined"

    # Suggested portfolio (auto-suggested, user can override)
    suggested_portfolio: Optional[str] = None

    # Lifecycle
    status: RecommendationStatus = RecommendationStatus.PENDING
    created_at: datetime = field(default_factory=datetime.utcnow)
    reviewed_at: Optional[datetime] = None

    # If accepted
    accepted_notes: str = ""            # User's rationale for accepting
    trade_id: Optional[str] = None      # Trade ID created from this recommendation
    portfolio_name: Optional[str] = None  # Portfolio the trade was booked into

    # If rejected
    rejection_reason: str = ""

    # Scenario-based fields (populated by scenario screeners)
    scenario_template_name: Optional[str] = None      # e.g. "correction_premium_sell"
    scenario_type: Optional[str] = None                # "correction", "earnings", "black_swan", "arbitrage"
    trigger_conditions_met: Dict[str, Any] = field(default_factory=dict)

    def accept(self, notes: str = "", trade_id: str = "", portfolio_name: str = ""):
        """Accept this recommendation."""
        self.status = RecommendationStatus.ACCEPTED
        self.reviewed_at = datetime.utcnow()
        self.accepted_notes = notes
        self.trade_id = trade_id
        self.portfolio_name = portfolio_name

    def reject(self, reason: str = ""):
        """Reject this recommendation."""
        self.status = RecommendationStatus.REJECTED
        self.reviewed_at = datetime.utcnow()
        self.rejection_reason = reason

    def expire(self):
        """Mark as expired."""
        self.status = RecommendationStatus.EXPIRED
        self.reviewed_at = datetime.utcnow()

    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'recommendation_type': self.recommendation_type.value,
            'source': self.source,
            'screener_name': self.screener_name,
            'underlying': self.underlying,
            'strategy_type': self.strategy_type,
            'legs': [l.to_dict() for l in self.legs],
            'market_context': self.market_context.to_dict(),
            'confidence': self.confidence,
            'rationale': self.rationale,
            'risk_category': self.risk_category,
            'suggested_portfolio': self.suggested_portfolio,
            'status': self.status.value,
            'created_at': self.created_at.isoformat(),
            'reviewed_at': self.reviewed_at.isoformat() if self.reviewed_at else None,
            'trade_id': self.trade_id,
            'trade_id_to_close': self.trade_id_to_close,
            'exit_action': self.exit_action,
            'exit_urgency': self.exit_urgency,
            'triggered_rules': self.triggered_rules,
            'new_legs': [l.to_dict() for l in self.new_legs],
            'scenario_template_name': self.scenario_template_name,
            'scenario_type': self.scenario_type,
            'trigger_conditions_met': self.trigger_conditions_met,
        }


@dataclass
class Watchlist:
    """
    A watchlist of symbols to screen against.

    Can come from TastyTrade public watchlists or be user-defined.
    Cached in DB for offline use.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    source: str = "custom"              # "tastytrade" or "custom"
    symbols: List[str] = field(default_factory=list)
    description: str = ""
    created_at: datetime = field(default_factory=datetime.utcnow)
    last_refreshed: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'name': self.name,
            'source': self.source,
            'symbols': self.symbols,
            'symbol_count': len(self.symbols),
            'description': self.description,
            'last_refreshed': self.last_refreshed.isoformat() if self.last_refreshed else None,
        }
